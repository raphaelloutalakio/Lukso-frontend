/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface ERAInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "auctions"
      | "bundles"
      | "collectionApplications"
      | "list"
      | "listIdToOffers"
      | "lists"
      | "marketplace"
      | "omnichainEraAddr"
      | "owner"
      | "royaltyCollections"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AuctionCreated"
      | "AuctionEnded"
      | "BidPlaced"
      | "BundleCreated"
      | "BundlePurchased"
      | "ChangePrice"
      | "CollectionApplication"
      | "CollectionApplicationApproved"
      | "ItemDelisted"
      | "ItemPurchased"
      | "Listed"
      | "OfferRemoved"
      | "Offered"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "auctions",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "bundles",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "collectionApplications",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "list",
    values: [AddressLike, BytesLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "listIdToOffers",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "lists", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "marketplace",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "omnichainEraAddr",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "royaltyCollections",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "auctions", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bundles", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "collectionApplications",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "list", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "listIdToOffers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketplace",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "omnichainEraAddr",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "royaltyCollections",
    data: BytesLike
  ): Result;
}

export namespace AuctionCreatedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BigNumberish,
    paymentToken: AddressLike,
    minBid: BigNumberish,
    minBidIncrement: BigNumberish,
    startTime: BigNumberish,
    expirationTime: BigNumberish,
    owner: AddressLike,
    seller: AddressLike
  ];
  export type OutputTuple = [
    auctionId: bigint,
    nftAddress: string,
    tokenId: bigint,
    paymentToken: string,
    minBid: bigint,
    minBidIncrement: bigint,
    startTime: bigint,
    expirationTime: bigint,
    owner: string,
    seller: string
  ];
  export interface OutputObject {
    auctionId: bigint;
    nftAddress: string;
    tokenId: bigint;
    paymentToken: string;
    minBid: bigint;
    minBidIncrement: bigint;
    startTime: bigint;
    expirationTime: bigint;
    owner: string;
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AuctionEndedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BigNumberish,
    paymentToken: AddressLike,
    winner: AddressLike,
    winningBid: BigNumberish
  ];
  export type OutputTuple = [
    auctionId: bigint,
    nftAddress: string,
    tokenId: bigint,
    paymentToken: string,
    winner: string,
    winningBid: bigint
  ];
  export interface OutputObject {
    auctionId: bigint;
    nftAddress: string;
    tokenId: bigint;
    paymentToken: string;
    winner: string;
    winningBid: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BidPlacedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    bidder: AddressLike,
    bidAmount: BigNumberish
  ];
  export type OutputTuple = [
    auctionId: bigint,
    bidder: string,
    bidAmount: bigint
  ];
  export interface OutputObject {
    auctionId: bigint;
    bidder: string;
    bidAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BundleCreatedEvent {
  export type InputTuple = [
    bundle_id: BigNumberish,
    nftAddresses: AddressLike[],
    tokenIds: BigNumberish[],
    paymentTokens: AddressLike[],
    prices: BigNumberish[],
    seller: AddressLike
  ];
  export type OutputTuple = [
    bundle_id: bigint,
    nftAddresses: string[],
    tokenIds: bigint[],
    paymentTokens: string[],
    prices: bigint[],
    seller: string
  ];
  export interface OutputObject {
    bundle_id: bigint;
    nftAddresses: string[];
    tokenIds: bigint[];
    paymentTokens: string[];
    prices: bigint[];
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BundlePurchasedEvent {
  export type InputTuple = [
    bundle_id: BigNumberish,
    buyer: AddressLike,
    seller: AddressLike
  ];
  export type OutputTuple = [bundle_id: bigint, buyer: string, seller: string];
  export interface OutputObject {
    bundle_id: bigint;
    buyer: string;
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChangePriceEvent {
  export type InputTuple = [
    item_id: BigNumberish,
    paymentToken: AddressLike,
    ask: BigNumberish
  ];
  export type OutputTuple = [
    item_id: bigint,
    paymentToken: string,
    ask: bigint
  ];
  export interface OutputObject {
    item_id: bigint;
    paymentToken: string;
    ask: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CollectionApplicationEvent {
  export type InputTuple = [
    application_id: BigNumberish,
    applicant: AddressLike,
    collectionName: string,
    NFTContract: AddressLike,
    royaltyCollector: AddressLike,
    bps: BigNumberish,
    approved: boolean
  ];
  export type OutputTuple = [
    application_id: bigint,
    applicant: string,
    collectionName: string,
    NFTContract: string,
    royaltyCollector: string,
    bps: bigint,
    approved: boolean
  ];
  export interface OutputObject {
    application_id: bigint;
    applicant: string;
    collectionName: string;
    NFTContract: string;
    royaltyCollector: string;
    bps: bigint;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CollectionApplicationApprovedEvent {
  export type InputTuple = [
    applicationId: BigNumberish,
    applicant: AddressLike
  ];
  export type OutputTuple = [applicationId: bigint, applicant: string];
  export interface OutputObject {
    applicationId: bigint;
    applicant: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ItemDelistedEvent {
  export type InputTuple = [
    list_id: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    ask: BigNumberish,
    owner: AddressLike,
    lister: AddressLike
  ];
  export type OutputTuple = [
    list_id: bigint,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    ask: bigint,
    owner: string,
    lister: string
  ];
  export interface OutputObject {
    list_id: bigint;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    ask: bigint;
    owner: string;
    lister: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ItemPurchasedEvent {
  export type InputTuple = [
    buyer: AddressLike,
    lister: AddressLike,
    listId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BigNumberish,
    paymentToken: AddressLike,
    totalPrice: BigNumberish
  ];
  export type OutputTuple = [
    buyer: string,
    lister: string,
    listId: bigint,
    nftAddress: string,
    tokenId: bigint,
    paymentToken: string,
    totalPrice: bigint
  ];
  export interface OutputObject {
    buyer: string;
    lister: string;
    listId: bigint;
    nftAddress: string;
    tokenId: bigint;
    paymentToken: string;
    totalPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ListedEvent {
  export type InputTuple = [
    list_id: BigNumberish,
    lister: AddressLike,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    ask: BigNumberish,
    owner: AddressLike
  ];
  export type OutputTuple = [
    list_id: bigint,
    lister: string,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    ask: bigint,
    owner: string
  ];
  export interface OutputObject {
    list_id: bigint;
    lister: string;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    ask: bigint;
    owner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OfferRemovedEvent {
  export type InputTuple = [listId: BigNumberish, offerId: BigNumberish];
  export type OutputTuple = [listId: bigint, offerId: bigint];
  export interface OutputObject {
    listId: bigint;
    offerId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OfferedEvent {
  export type InputTuple = [
    listId: BigNumberish,
    offerId: BigNumberish,
    offerer: AddressLike,
    paymentToken: AddressLike,
    offerPrice: BigNumberish
  ];
  export type OutputTuple = [
    listId: bigint,
    offerId: bigint,
    offerer: string,
    paymentToken: string,
    offerPrice: bigint
  ];
  export interface OutputObject {
    listId: bigint;
    offerId: bigint;
    offerer: string;
    paymentToken: string;
    offerPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ERA extends BaseContract {
  connect(runner?: ContractRunner | null): ERA;
  waitForDeployment(): Promise<this>;

  interface: ERAInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  auctions: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        bigint,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        string,
        bigint,
        boolean
      ] & {
        auctionId: bigint;
        nftAddress: string;
        tokenId: bigint;
        paymentToken: string;
        minBid: bigint;
        minBidIncrement: bigint;
        startTime: bigint;
        expirationTime: bigint;
        owner: string;
        seller: string;
        highestBidder: string;
        highestBid: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  bundles: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, boolean] & {
        bundle_id: bigint;
        seller: string;
        active: boolean;
      }
    ],
    "view"
  >;

  collectionApplications: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, string, string, string, bigint, boolean] & {
        application_id: bigint;
        applicant: string;
        collectionName: string;
        NFTContract: string;
        royaltyCollector: string;
        bps: bigint;
        approved: boolean;
      }
    ],
    "view"
  >;

  list: TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _ask: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  listIdToOffers: TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish],
    [
      [bigint, string, string, bigint, boolean] & {
        offer_id: bigint;
        offerer: string;
        paymentToken: string;
        offerPrice: bigint;
        accepted: boolean;
      }
    ],
    "view"
  >;

  lists: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        list_id: bigint;
        lister: string;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        ask: bigint;
        owner: string;
        offers: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  marketplace: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, string, bigint] & {
        fee_pbs: bigint;
        collateral_fee: bigint;
        volume: bigint;
        listed: bigint;
        offered: bigint;
        auctioned: bigint;
        owner: string;
        nextApplicationId: bigint;
      }
    ],
    "view"
  >;

  omnichainEraAddr: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  royaltyCollections: TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, string] & {
        creator: string;
        bps: bigint;
        royaltyCollector: string;
      }
    ],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "auctions"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        bigint,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        string,
        bigint,
        boolean
      ] & {
        auctionId: bigint;
        nftAddress: string;
        tokenId: bigint;
        paymentToken: string;
        minBid: bigint;
        minBidIncrement: bigint;
        startTime: bigint;
        expirationTime: bigint;
        owner: string;
        seller: string;
        highestBidder: string;
        highestBid: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "bundles"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, boolean] & {
        bundle_id: bigint;
        seller: string;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "collectionApplications"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, string, string, string, bigint, boolean] & {
        application_id: bigint;
        applicant: string;
        collectionName: string;
        NFTContract: string;
        royaltyCollector: string;
        bps: bigint;
        approved: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "list"
  ): TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _ask: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "listIdToOffers"
  ): TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish],
    [
      [bigint, string, string, bigint, boolean] & {
        offer_id: bigint;
        offerer: string;
        paymentToken: string;
        offerPrice: bigint;
        accepted: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "lists"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        list_id: bigint;
        lister: string;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        ask: bigint;
        owner: string;
        offers: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "marketplace"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, string, bigint] & {
        fee_pbs: bigint;
        collateral_fee: bigint;
        volume: bigint;
        listed: bigint;
        offered: bigint;
        auctioned: bigint;
        owner: string;
        nextApplicationId: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "omnichainEraAddr"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "royaltyCollections"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, string] & {
        creator: string;
        bps: bigint;
        royaltyCollector: string;
      }
    ],
    "view"
  >;

  getEvent(
    key: "AuctionCreated"
  ): TypedContractEvent<
    AuctionCreatedEvent.InputTuple,
    AuctionCreatedEvent.OutputTuple,
    AuctionCreatedEvent.OutputObject
  >;
  getEvent(
    key: "AuctionEnded"
  ): TypedContractEvent<
    AuctionEndedEvent.InputTuple,
    AuctionEndedEvent.OutputTuple,
    AuctionEndedEvent.OutputObject
  >;
  getEvent(
    key: "BidPlaced"
  ): TypedContractEvent<
    BidPlacedEvent.InputTuple,
    BidPlacedEvent.OutputTuple,
    BidPlacedEvent.OutputObject
  >;
  getEvent(
    key: "BundleCreated"
  ): TypedContractEvent<
    BundleCreatedEvent.InputTuple,
    BundleCreatedEvent.OutputTuple,
    BundleCreatedEvent.OutputObject
  >;
  getEvent(
    key: "BundlePurchased"
  ): TypedContractEvent<
    BundlePurchasedEvent.InputTuple,
    BundlePurchasedEvent.OutputTuple,
    BundlePurchasedEvent.OutputObject
  >;
  getEvent(
    key: "ChangePrice"
  ): TypedContractEvent<
    ChangePriceEvent.InputTuple,
    ChangePriceEvent.OutputTuple,
    ChangePriceEvent.OutputObject
  >;
  getEvent(
    key: "CollectionApplication"
  ): TypedContractEvent<
    CollectionApplicationEvent.InputTuple,
    CollectionApplicationEvent.OutputTuple,
    CollectionApplicationEvent.OutputObject
  >;
  getEvent(
    key: "CollectionApplicationApproved"
  ): TypedContractEvent<
    CollectionApplicationApprovedEvent.InputTuple,
    CollectionApplicationApprovedEvent.OutputTuple,
    CollectionApplicationApprovedEvent.OutputObject
  >;
  getEvent(
    key: "ItemDelisted"
  ): TypedContractEvent<
    ItemDelistedEvent.InputTuple,
    ItemDelistedEvent.OutputTuple,
    ItemDelistedEvent.OutputObject
  >;
  getEvent(
    key: "ItemPurchased"
  ): TypedContractEvent<
    ItemPurchasedEvent.InputTuple,
    ItemPurchasedEvent.OutputTuple,
    ItemPurchasedEvent.OutputObject
  >;
  getEvent(
    key: "Listed"
  ): TypedContractEvent<
    ListedEvent.InputTuple,
    ListedEvent.OutputTuple,
    ListedEvent.OutputObject
  >;
  getEvent(
    key: "OfferRemoved"
  ): TypedContractEvent<
    OfferRemovedEvent.InputTuple,
    OfferRemovedEvent.OutputTuple,
    OfferRemovedEvent.OutputObject
  >;
  getEvent(
    key: "Offered"
  ): TypedContractEvent<
    OfferedEvent.InputTuple,
    OfferedEvent.OutputTuple,
    OfferedEvent.OutputObject
  >;

  filters: {
    "AuctionCreated(uint256,address,uint64,address,uint256,uint256,uint256,uint256,address,address)": TypedContractEvent<
      AuctionCreatedEvent.InputTuple,
      AuctionCreatedEvent.OutputTuple,
      AuctionCreatedEvent.OutputObject
    >;
    AuctionCreated: TypedContractEvent<
      AuctionCreatedEvent.InputTuple,
      AuctionCreatedEvent.OutputTuple,
      AuctionCreatedEvent.OutputObject
    >;

    "AuctionEnded(uint256,address,uint64,address,address,uint256)": TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;
    AuctionEnded: TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;

    "BidPlaced(uint256,address,uint256)": TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;
    BidPlaced: TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;

    "BundleCreated(uint256,address[],uint64[],address[],uint256[],address)": TypedContractEvent<
      BundleCreatedEvent.InputTuple,
      BundleCreatedEvent.OutputTuple,
      BundleCreatedEvent.OutputObject
    >;
    BundleCreated: TypedContractEvent<
      BundleCreatedEvent.InputTuple,
      BundleCreatedEvent.OutputTuple,
      BundleCreatedEvent.OutputObject
    >;

    "BundlePurchased(uint256,address,address)": TypedContractEvent<
      BundlePurchasedEvent.InputTuple,
      BundlePurchasedEvent.OutputTuple,
      BundlePurchasedEvent.OutputObject
    >;
    BundlePurchased: TypedContractEvent<
      BundlePurchasedEvent.InputTuple,
      BundlePurchasedEvent.OutputTuple,
      BundlePurchasedEvent.OutputObject
    >;

    "ChangePrice(uint64,address,uint64)": TypedContractEvent<
      ChangePriceEvent.InputTuple,
      ChangePriceEvent.OutputTuple,
      ChangePriceEvent.OutputObject
    >;
    ChangePrice: TypedContractEvent<
      ChangePriceEvent.InputTuple,
      ChangePriceEvent.OutputTuple,
      ChangePriceEvent.OutputObject
    >;

    "CollectionApplication(uint256,address,string,address,address,uint256,bool)": TypedContractEvent<
      CollectionApplicationEvent.InputTuple,
      CollectionApplicationEvent.OutputTuple,
      CollectionApplicationEvent.OutputObject
    >;
    CollectionApplication: TypedContractEvent<
      CollectionApplicationEvent.InputTuple,
      CollectionApplicationEvent.OutputTuple,
      CollectionApplicationEvent.OutputObject
    >;

    "CollectionApplicationApproved(uint256,address)": TypedContractEvent<
      CollectionApplicationApprovedEvent.InputTuple,
      CollectionApplicationApprovedEvent.OutputTuple,
      CollectionApplicationApprovedEvent.OutputObject
    >;
    CollectionApplicationApproved: TypedContractEvent<
      CollectionApplicationApprovedEvent.InputTuple,
      CollectionApplicationApprovedEvent.OutputTuple,
      CollectionApplicationApprovedEvent.OutputObject
    >;

    "ItemDelisted(uint64,address,bytes32,address,uint128,address,address)": TypedContractEvent<
      ItemDelistedEvent.InputTuple,
      ItemDelistedEvent.OutputTuple,
      ItemDelistedEvent.OutputObject
    >;
    ItemDelisted: TypedContractEvent<
      ItemDelistedEvent.InputTuple,
      ItemDelistedEvent.OutputTuple,
      ItemDelistedEvent.OutputObject
    >;

    "ItemPurchased(address,address,uint64,address,uint64,address,uint256)": TypedContractEvent<
      ItemPurchasedEvent.InputTuple,
      ItemPurchasedEvent.OutputTuple,
      ItemPurchasedEvent.OutputObject
    >;
    ItemPurchased: TypedContractEvent<
      ItemPurchasedEvent.InputTuple,
      ItemPurchasedEvent.OutputTuple,
      ItemPurchasedEvent.OutputObject
    >;

    "Listed(uint64,address,address,bytes32,address,uint128,address)": TypedContractEvent<
      ListedEvent.InputTuple,
      ListedEvent.OutputTuple,
      ListedEvent.OutputObject
    >;
    Listed: TypedContractEvent<
      ListedEvent.InputTuple,
      ListedEvent.OutputTuple,
      ListedEvent.OutputObject
    >;

    "OfferRemoved(uint64,uint64)": TypedContractEvent<
      OfferRemovedEvent.InputTuple,
      OfferRemovedEvent.OutputTuple,
      OfferRemovedEvent.OutputObject
    >;
    OfferRemoved: TypedContractEvent<
      OfferRemovedEvent.InputTuple,
      OfferRemovedEvent.OutputTuple,
      OfferRemovedEvent.OutputObject
    >;

    "Offered(uint64,uint64,address,address,uint64)": TypedContractEvent<
      OfferedEvent.InputTuple,
      OfferedEvent.OutputTuple,
      OfferedEvent.OutputObject
    >;
    Offered: TypedContractEvent<
      OfferedEvent.InputTuple,
      OfferedEvent.OutputTuple,
      OfferedEvent.OutputObject
    >;
  };
}
