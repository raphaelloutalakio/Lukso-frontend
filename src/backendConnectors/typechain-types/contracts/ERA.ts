/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface ERAInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "acceptOffer"
      | "add_royalty_collection"
      | "applyForCollectionLaunch"
      | "approveCollectionApplication"
      | "auctions"
      | "bundles"
      | "buy"
      | "buyBundle"
      | "calculateFees"
      | "calculateRoyaltyCollectionFee"
      | "changePrice"
      | "check_exists_royalty_collection"
      | "collectionApplications"
      | "createBundle"
      | "delist"
      | "endAuction"
      | "list"
      | "listAuction"
      | "listIdToOffers"
      | "lists"
      | "makeOffer"
      | "marketplace"
      | "mutateCollateralFees"
      | "mutateFeesPbs"
      | "mutateOwner"
      | "omnichainEraAddr"
      | "owner"
      | "placeBid"
      | "removeOffer"
      | "royaltyCollections"
      | "update_royalty_collection"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AuctionCreated"
      | "AuctionEnded"
      | "BidPlaced"
      | "BundleCreated"
      | "BundlePurchased"
      | "ChangePrice"
      | "CollectionApplication"
      | "CollectionApplicationApproved"
      | "ItemDelisted"
      | "ItemPurchased"
      | "Listed"
      | "OfferRemoved"
      | "Offered"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "acceptOffer",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "add_royalty_collection",
    values: [AddressLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "applyForCollectionLaunch",
    values: [string, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveCollectionApplication",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "auctions",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "bundles",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "buy", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "buyBundle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateFees",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRoyaltyCollectionFee",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changePrice",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "check_exists_royalty_collection",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "collectionApplications",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createBundle",
    values: [AddressLike[], BytesLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "delist",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "endAuction",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "list",
    values: [AddressLike, BytesLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "listAuction",
    values: [
      AddressLike,
      BytesLike,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "listIdToOffers",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "lists", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "makeOffer",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "marketplace",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mutateCollateralFees",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mutateFeesPbs",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mutateOwner",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "omnichainEraAddr",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "placeBid",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeOffer",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "royaltyCollections",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "update_royalty_collection",
    values: [AddressLike, BigNumberish, AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "add_royalty_collection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "applyForCollectionLaunch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveCollectionApplication",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "auctions", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bundles", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buyBundle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRoyaltyCollectionFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "check_exists_royalty_collection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectionApplications",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "delist", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "endAuction", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "list", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "listAuction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listIdToOffers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lists", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "makeOffer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketplace",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mutateCollateralFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mutateFeesPbs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mutateOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "omnichainEraAddr",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "placeBid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "royaltyCollections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "update_royalty_collection",
    data: BytesLike
  ): Result;
}

export namespace AuctionCreatedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    minBid: BigNumberish,
    minBidIncrement: BigNumberish,
    startTime: BigNumberish,
    expirationTime: BigNumberish,
    owner: AddressLike,
    seller: AddressLike
  ];
  export type OutputTuple = [
    auctionId: bigint,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    minBid: bigint,
    minBidIncrement: bigint,
    startTime: bigint,
    expirationTime: bigint,
    owner: string,
    seller: string
  ];
  export interface OutputObject {
    auctionId: bigint;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    minBid: bigint;
    minBidIncrement: bigint;
    startTime: bigint;
    expirationTime: bigint;
    owner: string;
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AuctionEndedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    winner: AddressLike,
    winningBid: BigNumberish
  ];
  export type OutputTuple = [
    auctionId: bigint,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    winner: string,
    winningBid: bigint
  ];
  export interface OutputObject {
    auctionId: bigint;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    winner: string;
    winningBid: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BidPlacedEvent {
  export type InputTuple = [
    auctionId: BigNumberish,
    bidder: AddressLike,
    bidAmount: BigNumberish
  ];
  export type OutputTuple = [
    auctionId: bigint,
    bidder: string,
    bidAmount: bigint
  ];
  export interface OutputObject {
    auctionId: bigint;
    bidder: string;
    bidAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BundleCreatedEvent {
  export type InputTuple = [
    bundle_id: BigNumberish,
    nftAddresses: AddressLike[],
    tokenIds: BytesLike[],
    paymentTokens: AddressLike[],
    prices: BigNumberish[],
    seller: AddressLike
  ];
  export type OutputTuple = [
    bundle_id: bigint,
    nftAddresses: string[],
    tokenIds: string[],
    paymentTokens: string[],
    prices: bigint[],
    seller: string
  ];
  export interface OutputObject {
    bundle_id: bigint;
    nftAddresses: string[];
    tokenIds: string[];
    paymentTokens: string[];
    prices: bigint[];
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BundlePurchasedEvent {
  export type InputTuple = [
    bundle_id: BigNumberish,
    buyer: AddressLike,
    seller: AddressLike
  ];
  export type OutputTuple = [bundle_id: bigint, buyer: string, seller: string];
  export interface OutputObject {
    bundle_id: bigint;
    buyer: string;
    seller: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChangePriceEvent {
  export type InputTuple = [
    item_id: BigNumberish,
    paymentToken: AddressLike,
    ask: BigNumberish
  ];
  export type OutputTuple = [
    item_id: bigint,
    paymentToken: string,
    ask: bigint
  ];
  export interface OutputObject {
    item_id: bigint;
    paymentToken: string;
    ask: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CollectionApplicationEvent {
  export type InputTuple = [
    application_id: BigNumberish,
    applicant: AddressLike,
    collectionName: string,
    NFTContract: AddressLike,
    royaltyCollector: AddressLike,
    bps: BigNumberish,
    approved: boolean
  ];
  export type OutputTuple = [
    application_id: bigint,
    applicant: string,
    collectionName: string,
    NFTContract: string,
    royaltyCollector: string,
    bps: bigint,
    approved: boolean
  ];
  export interface OutputObject {
    application_id: bigint;
    applicant: string;
    collectionName: string;
    NFTContract: string;
    royaltyCollector: string;
    bps: bigint;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CollectionApplicationApprovedEvent {
  export type InputTuple = [
    applicationId: BigNumberish,
    applicant: AddressLike
  ];
  export type OutputTuple = [applicationId: bigint, applicant: string];
  export interface OutputObject {
    applicationId: bigint;
    applicant: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ItemDelistedEvent {
  export type InputTuple = [
    list_id: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    ask: BigNumberish,
    owner: AddressLike,
    lister: AddressLike
  ];
  export type OutputTuple = [
    list_id: bigint,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    ask: bigint,
    owner: string,
    lister: string
  ];
  export interface OutputObject {
    list_id: bigint;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    ask: bigint;
    owner: string;
    lister: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ItemPurchasedEvent {
  export type InputTuple = [
    buyer: AddressLike,
    lister: AddressLike,
    listId: BigNumberish,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    totalPrice: BigNumberish
  ];
  export type OutputTuple = [
    buyer: string,
    lister: string,
    listId: bigint,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    totalPrice: bigint
  ];
  export interface OutputObject {
    buyer: string;
    lister: string;
    listId: bigint;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    totalPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ListedEvent {
  export type InputTuple = [
    list_id: BigNumberish,
    lister: AddressLike,
    nftAddress: AddressLike,
    tokenId: BytesLike,
    paymentToken: AddressLike,
    ask: BigNumberish,
    owner: AddressLike
  ];
  export type OutputTuple = [
    list_id: bigint,
    lister: string,
    nftAddress: string,
    tokenId: string,
    paymentToken: string,
    ask: bigint,
    owner: string
  ];
  export interface OutputObject {
    list_id: bigint;
    lister: string;
    nftAddress: string;
    tokenId: string;
    paymentToken: string;
    ask: bigint;
    owner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OfferRemovedEvent {
  export type InputTuple = [listId: BigNumberish, offerId: BigNumberish];
  export type OutputTuple = [listId: bigint, offerId: bigint];
  export interface OutputObject {
    listId: bigint;
    offerId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OfferedEvent {
  export type InputTuple = [
    listId: BigNumberish,
    offerId: BigNumberish,
    offerer: AddressLike,
    paymentToken: AddressLike,
    offerPrice: BigNumberish
  ];
  export type OutputTuple = [
    listId: bigint,
    offerId: bigint,
    offerer: string,
    paymentToken: string,
    offerPrice: bigint
  ];
  export interface OutputObject {
    listId: bigint;
    offerId: bigint;
    offerer: string;
    paymentToken: string;
    offerPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ERA extends BaseContract {
  connect(runner?: ContractRunner | null): ERA;
  waitForDeployment(): Promise<this>;

  interface: ERAInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  acceptOffer: TypedContractMethod<
    [_listId: BigNumberish, _offerId: BigNumberish],
    [void],
    "nonpayable"
  >;

  add_royalty_collection: TypedContractMethod<
    [
      _nftAddress: AddressLike,
      bps: BigNumberish,
      royaltyCollector: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  applyForCollectionLaunch: TypedContractMethod<
    [
      _collectionName: string,
      _NFTContract: AddressLike,
      _royaltyCollector: AddressLike,
      _bps: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  approveCollectionApplication: TypedContractMethod<
    [applicationId: BigNumberish],
    [void],
    "nonpayable"
  >;

  auctions: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        string,
        bigint,
        boolean
      ] & {
        auctionId: bigint;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        minBid: bigint;
        minBidIncrement: bigint;
        startTime: bigint;
        expirationTime: bigint;
        owner: string;
        seller: string;
        highestBidder: string;
        highestBid: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  bundles: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, boolean] & {
        bundle_id: bigint;
        seller: string;
        active: boolean;
      }
    ],
    "view"
  >;

  buy: TypedContractMethod<[_listId: BigNumberish], [void], "nonpayable">;

  buyBundle: TypedContractMethod<
    [bundle_id: BigNumberish],
    [void],
    "nonpayable"
  >;

  calculateFees: TypedContractMethod<
    [amount: BigNumberish, fee_pbs: BigNumberish, collateral_fee: BigNumberish],
    [bigint],
    "view"
  >;

  calculateRoyaltyCollectionFee: TypedContractMethod<
    [_nftAddress: AddressLike, amount: BigNumberish],
    [bigint],
    "view"
  >;

  changePrice: TypedContractMethod<
    [_listId: BigNumberish, _paymentToken: AddressLike, _ask: BigNumberish],
    [void],
    "nonpayable"
  >;

  check_exists_royalty_collection: TypedContractMethod<
    [_nftAddress: AddressLike],
    [boolean],
    "view"
  >;

  collectionApplications: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, string, string, string, bigint, boolean] & {
        application_id: bigint;
        applicant: string;
        collectionName: string;
        NFTContract: string;
        royaltyCollector: string;
        bps: bigint;
        approved: boolean;
      }
    ],
    "view"
  >;

  createBundle: TypedContractMethod<
    [
      _nftAddresses: AddressLike[],
      _tokenIds: BytesLike[],
      _paymentTokens: AddressLike[],
      _prices: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  delist: TypedContractMethod<
    [_lister: AddressLike, _listId: BigNumberish],
    [void],
    "nonpayable"
  >;

  endAuction: TypedContractMethod<
    [_auctionId: BigNumberish],
    [void],
    "nonpayable"
  >;

  list: TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _ask: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  listAuction: TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _minBid: BigNumberish,
      _minBidIncrement: BigNumberish,
      _startTime: BigNumberish,
      _expirationTime: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  listIdToOffers: TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish],
    [
      [bigint, string, string, bigint, boolean] & {
        offer_id: bigint;
        offerer: string;
        paymentToken: string;
        offerPrice: bigint;
        accepted: boolean;
      }
    ],
    "view"
  >;

  lists: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        list_id: bigint;
        lister: string;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        ask: bigint;
        owner: string;
        offers: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  makeOffer: TypedContractMethod<
    [
      _listId: BigNumberish,
      _paymentToken: AddressLike,
      _offerPrice: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  marketplace: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, string, bigint] & {
        fee_pbs: bigint;
        collateral_fee: bigint;
        volume: bigint;
        listed: bigint;
        offered: bigint;
        auctioned: bigint;
        owner: string;
        nextApplicationId: bigint;
      }
    ],
    "view"
  >;

  mutateCollateralFees: TypedContractMethod<
    [new_collateral_fee: BigNumberish],
    [void],
    "nonpayable"
  >;

  mutateFeesPbs: TypedContractMethod<
    [new_fee_pbs: BigNumberish],
    [void],
    "nonpayable"
  >;

  mutateOwner: TypedContractMethod<
    [new_owner: AddressLike],
    [void],
    "nonpayable"
  >;

  omnichainEraAddr: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  placeBid: TypedContractMethod<
    [_auctionId: BigNumberish, _bidAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  removeOffer: TypedContractMethod<
    [_listId: BigNumberish, _offerId: BigNumberish],
    [void],
    "nonpayable"
  >;

  royaltyCollections: TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, string] & {
        creator: string;
        bps: bigint;
        royaltyCollector: string;
      }
    ],
    "view"
  >;

  update_royalty_collection: TypedContractMethod<
    [
      _nftAddress: AddressLike,
      bps: BigNumberish,
      royaltyCollector: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "acceptOffer"
  ): TypedContractMethod<
    [_listId: BigNumberish, _offerId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "add_royalty_collection"
  ): TypedContractMethod<
    [
      _nftAddress: AddressLike,
      bps: BigNumberish,
      royaltyCollector: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "applyForCollectionLaunch"
  ): TypedContractMethod<
    [
      _collectionName: string,
      _NFTContract: AddressLike,
      _royaltyCollector: AddressLike,
      _bps: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveCollectionApplication"
  ): TypedContractMethod<[applicationId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "auctions"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        string,
        bigint,
        boolean
      ] & {
        auctionId: bigint;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        minBid: bigint;
        minBidIncrement: bigint;
        startTime: bigint;
        expirationTime: bigint;
        owner: string;
        seller: string;
        highestBidder: string;
        highestBid: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "bundles"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, boolean] & {
        bundle_id: bigint;
        seller: string;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "buy"
  ): TypedContractMethod<[_listId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "buyBundle"
  ): TypedContractMethod<[bundle_id: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "calculateFees"
  ): TypedContractMethod<
    [amount: BigNumberish, fee_pbs: BigNumberish, collateral_fee: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "calculateRoyaltyCollectionFee"
  ): TypedContractMethod<
    [_nftAddress: AddressLike, amount: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "changePrice"
  ): TypedContractMethod<
    [_listId: BigNumberish, _paymentToken: AddressLike, _ask: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "check_exists_royalty_collection"
  ): TypedContractMethod<[_nftAddress: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "collectionApplications"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, string, string, string, bigint, boolean] & {
        application_id: bigint;
        applicant: string;
        collectionName: string;
        NFTContract: string;
        royaltyCollector: string;
        bps: bigint;
        approved: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "createBundle"
  ): TypedContractMethod<
    [
      _nftAddresses: AddressLike[],
      _tokenIds: BytesLike[],
      _paymentTokens: AddressLike[],
      _prices: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "delist"
  ): TypedContractMethod<
    [_lister: AddressLike, _listId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "endAuction"
  ): TypedContractMethod<[_auctionId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "list"
  ): TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _ask: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "listAuction"
  ): TypedContractMethod<
    [
      _nftAddress: AddressLike,
      _tokenId: BytesLike,
      _paymentToken: AddressLike,
      _minBid: BigNumberish,
      _minBidIncrement: BigNumberish,
      _startTime: BigNumberish,
      _expirationTime: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "listIdToOffers"
  ): TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish],
    [
      [bigint, string, string, bigint, boolean] & {
        offer_id: bigint;
        offerer: string;
        paymentToken: string;
        offerPrice: bigint;
        accepted: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "lists"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        string,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        list_id: bigint;
        lister: string;
        nftAddress: string;
        tokenId: string;
        paymentToken: string;
        ask: bigint;
        owner: string;
        offers: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "makeOffer"
  ): TypedContractMethod<
    [
      _listId: BigNumberish,
      _paymentToken: AddressLike,
      _offerPrice: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "marketplace"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, string, bigint] & {
        fee_pbs: bigint;
        collateral_fee: bigint;
        volume: bigint;
        listed: bigint;
        offered: bigint;
        auctioned: bigint;
        owner: string;
        nextApplicationId: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "mutateCollateralFees"
  ): TypedContractMethod<
    [new_collateral_fee: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mutateFeesPbs"
  ): TypedContractMethod<[new_fee_pbs: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "mutateOwner"
  ): TypedContractMethod<[new_owner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "omnichainEraAddr"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "placeBid"
  ): TypedContractMethod<
    [_auctionId: BigNumberish, _bidAmount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "removeOffer"
  ): TypedContractMethod<
    [_listId: BigNumberish, _offerId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "royaltyCollections"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, string] & {
        creator: string;
        bps: bigint;
        royaltyCollector: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "update_royalty_collection"
  ): TypedContractMethod<
    [
      _nftAddress: AddressLike,
      bps: BigNumberish,
      royaltyCollector: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "AuctionCreated"
  ): TypedContractEvent<
    AuctionCreatedEvent.InputTuple,
    AuctionCreatedEvent.OutputTuple,
    AuctionCreatedEvent.OutputObject
  >;
  getEvent(
    key: "AuctionEnded"
  ): TypedContractEvent<
    AuctionEndedEvent.InputTuple,
    AuctionEndedEvent.OutputTuple,
    AuctionEndedEvent.OutputObject
  >;
  getEvent(
    key: "BidPlaced"
  ): TypedContractEvent<
    BidPlacedEvent.InputTuple,
    BidPlacedEvent.OutputTuple,
    BidPlacedEvent.OutputObject
  >;
  getEvent(
    key: "BundleCreated"
  ): TypedContractEvent<
    BundleCreatedEvent.InputTuple,
    BundleCreatedEvent.OutputTuple,
    BundleCreatedEvent.OutputObject
  >;
  getEvent(
    key: "BundlePurchased"
  ): TypedContractEvent<
    BundlePurchasedEvent.InputTuple,
    BundlePurchasedEvent.OutputTuple,
    BundlePurchasedEvent.OutputObject
  >;
  getEvent(
    key: "ChangePrice"
  ): TypedContractEvent<
    ChangePriceEvent.InputTuple,
    ChangePriceEvent.OutputTuple,
    ChangePriceEvent.OutputObject
  >;
  getEvent(
    key: "CollectionApplication"
  ): TypedContractEvent<
    CollectionApplicationEvent.InputTuple,
    CollectionApplicationEvent.OutputTuple,
    CollectionApplicationEvent.OutputObject
  >;
  getEvent(
    key: "CollectionApplicationApproved"
  ): TypedContractEvent<
    CollectionApplicationApprovedEvent.InputTuple,
    CollectionApplicationApprovedEvent.OutputTuple,
    CollectionApplicationApprovedEvent.OutputObject
  >;
  getEvent(
    key: "ItemDelisted"
  ): TypedContractEvent<
    ItemDelistedEvent.InputTuple,
    ItemDelistedEvent.OutputTuple,
    ItemDelistedEvent.OutputObject
  >;
  getEvent(
    key: "ItemPurchased"
  ): TypedContractEvent<
    ItemPurchasedEvent.InputTuple,
    ItemPurchasedEvent.OutputTuple,
    ItemPurchasedEvent.OutputObject
  >;
  getEvent(
    key: "Listed"
  ): TypedContractEvent<
    ListedEvent.InputTuple,
    ListedEvent.OutputTuple,
    ListedEvent.OutputObject
  >;
  getEvent(
    key: "OfferRemoved"
  ): TypedContractEvent<
    OfferRemovedEvent.InputTuple,
    OfferRemovedEvent.OutputTuple,
    OfferRemovedEvent.OutputObject
  >;
  getEvent(
    key: "Offered"
  ): TypedContractEvent<
    OfferedEvent.InputTuple,
    OfferedEvent.OutputTuple,
    OfferedEvent.OutputObject
  >;

  filters: {
    "AuctionCreated(uint256,address,bytes32,address,uint256,uint256,uint256,uint256,address,address)": TypedContractEvent<
      AuctionCreatedEvent.InputTuple,
      AuctionCreatedEvent.OutputTuple,
      AuctionCreatedEvent.OutputObject
    >;
    AuctionCreated: TypedContractEvent<
      AuctionCreatedEvent.InputTuple,
      AuctionCreatedEvent.OutputTuple,
      AuctionCreatedEvent.OutputObject
    >;

    "AuctionEnded(uint256,address,bytes32,address,address,uint256)": TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;
    AuctionEnded: TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;

    "BidPlaced(uint256,address,uint256)": TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;
    BidPlaced: TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;

    "BundleCreated(uint256,address[],bytes32[],address[],uint256[],address)": TypedContractEvent<
      BundleCreatedEvent.InputTuple,
      BundleCreatedEvent.OutputTuple,
      BundleCreatedEvent.OutputObject
    >;
    BundleCreated: TypedContractEvent<
      BundleCreatedEvent.InputTuple,
      BundleCreatedEvent.OutputTuple,
      BundleCreatedEvent.OutputObject
    >;

    "BundlePurchased(uint256,address,address)": TypedContractEvent<
      BundlePurchasedEvent.InputTuple,
      BundlePurchasedEvent.OutputTuple,
      BundlePurchasedEvent.OutputObject
    >;
    BundlePurchased: TypedContractEvent<
      BundlePurchasedEvent.InputTuple,
      BundlePurchasedEvent.OutputTuple,
      BundlePurchasedEvent.OutputObject
    >;

    "ChangePrice(uint64,address,uint64)": TypedContractEvent<
      ChangePriceEvent.InputTuple,
      ChangePriceEvent.OutputTuple,
      ChangePriceEvent.OutputObject
    >;
    ChangePrice: TypedContractEvent<
      ChangePriceEvent.InputTuple,
      ChangePriceEvent.OutputTuple,
      ChangePriceEvent.OutputObject
    >;

    "CollectionApplication(uint256,address,string,address,address,uint256,bool)": TypedContractEvent<
      CollectionApplicationEvent.InputTuple,
      CollectionApplicationEvent.OutputTuple,
      CollectionApplicationEvent.OutputObject
    >;
    CollectionApplication: TypedContractEvent<
      CollectionApplicationEvent.InputTuple,
      CollectionApplicationEvent.OutputTuple,
      CollectionApplicationEvent.OutputObject
    >;

    "CollectionApplicationApproved(uint256,address)": TypedContractEvent<
      CollectionApplicationApprovedEvent.InputTuple,
      CollectionApplicationApprovedEvent.OutputTuple,
      CollectionApplicationApprovedEvent.OutputObject
    >;
    CollectionApplicationApproved: TypedContractEvent<
      CollectionApplicationApprovedEvent.InputTuple,
      CollectionApplicationApprovedEvent.OutputTuple,
      CollectionApplicationApprovedEvent.OutputObject
    >;

    "ItemDelisted(uint64,address,bytes32,address,uint128,address,address)": TypedContractEvent<
      ItemDelistedEvent.InputTuple,
      ItemDelistedEvent.OutputTuple,
      ItemDelistedEvent.OutputObject
    >;
    ItemDelisted: TypedContractEvent<
      ItemDelistedEvent.InputTuple,
      ItemDelistedEvent.OutputTuple,
      ItemDelistedEvent.OutputObject
    >;

    "ItemPurchased(address,address,uint64,address,bytes32,address,uint256)": TypedContractEvent<
      ItemPurchasedEvent.InputTuple,
      ItemPurchasedEvent.OutputTuple,
      ItemPurchasedEvent.OutputObject
    >;
    ItemPurchased: TypedContractEvent<
      ItemPurchasedEvent.InputTuple,
      ItemPurchasedEvent.OutputTuple,
      ItemPurchasedEvent.OutputObject
    >;

    "Listed(uint64,address,address,bytes32,address,uint128,address)": TypedContractEvent<
      ListedEvent.InputTuple,
      ListedEvent.OutputTuple,
      ListedEvent.OutputObject
    >;
    Listed: TypedContractEvent<
      ListedEvent.InputTuple,
      ListedEvent.OutputTuple,
      ListedEvent.OutputObject
    >;

    "OfferRemoved(uint64,uint64)": TypedContractEvent<
      OfferRemovedEvent.InputTuple,
      OfferRemovedEvent.OutputTuple,
      OfferRemovedEvent.OutputObject
    >;
    OfferRemoved: TypedContractEvent<
      OfferRemovedEvent.InputTuple,
      OfferRemovedEvent.OutputTuple,
      OfferRemovedEvent.OutputObject
    >;

    "Offered(uint64,uint64,address,address,uint64)": TypedContractEvent<
      OfferedEvent.InputTuple,
      OfferedEvent.OutputTuple,
      OfferedEvent.OutputObject
    >;
    Offered: TypedContractEvent<
      OfferedEvent.InputTuple,
      OfferedEvent.OutputTuple,
      OfferedEvent.OutputObject
    >;
  };
}
